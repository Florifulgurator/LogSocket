/**
 *  LogSocket.js
 *  1-File parallel to 2-File LogSocket.java, Lggr.java
 *  An exercise in comparative JS/Java linguistics :-)
 * 
 *  Most variable names copied verbatim from Java, even if weird:
 *  e.g. cmdArgList = [];
 */

console.log("LogSocket.js: Hello World! 78");

if ( typeof LogSocket != "undefined" ) console.warn("LogSocket already exists");

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
var LogSocket = LogSocket || ( () => {
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// "Private namespace": Closure of an anonymous immediately invoked function.
// "Public methods" are in the returned object assigned to var LogSocket.
var TEST1 = true;

var sysT_T0 = performance.now(); // high resolution timestamp in milliseconds.
var sysT_Q = 1.0; //Clock/quartz drift
function sysT_ms() { return round3(sysT_Q*( performance.now()-sysT_T0) ); }


//-------------------------------------------------------------

var websocket;
var connectionTried = 0;

var Nr;  // Unique ID generated by LogSocketServer & set via "/START Nr"
var wsUri = "ws://localhost:8080/logsocket/ws"; // DOCU #57977fd8 LogSocketServer URI HARDWIRED
var shutDown = false;
var isOpen = false; // == true after /START was OK

var numLggrs = 0;	//Count of created Loggers. Used in Lggr.shortId

var realmLabel2lastLggrN2 = new Map();
var realm2labelsCode2LggrRefRcrdList = new Map();
class LggrRefRcrd { // Java record
	constructor(longIdX, nr, madeKnown, wref) {
		this.longIdX=longIdX; this.nr=nr; this.madeKnown=madeKnown; this.wref=wref;
	}
	longIdX; nr; madeKnown; wref;
}

var filteredRealmLabel = new Map();


var logBuffer = [];
var logBuffered = false;
var nrBuffer = [];
var nrBuffered = false;
var filter1 = new Set(); //DEV #6cb5e491

const illglLblChrsPttrn = new RegExp("[^#@A-Za-z0-9_]", "g");
const illglRlmChrsPttrn = new RegExp("\W", "g");

const shortId2PromiseRslv = new Map(); // For logs with buttons. shortId2CFuture in LogSocket.java

const finalizeRgstr = new FinalizationRegistry( val => {finalizeLggr(val);} ); // Lggr garbage collection



//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Basic WebSocket infrastructure

function onOpen(evt) {
	connectionTried = 0;
	console.log(`WebSocket OPEN: ${(evt.data?evt.data+" ":"")}wsUri=${wsUri}`);

	websocket.send("!GREETS");
}
//---
function onError(evt) {
	// If an error occurs while attempting to connect, first a simple event with the name error is sent to the WebSocket object (thereby invoking its onerror handler),
	// and then the CloseEvent is sent to the WebSocket object (thereby invoking its onclose handler) to indicate the reason for the connection's closing.
	if (connectionTried) {
		console.log(`WebSocketServer: No reply. Trying again (${++connectionTried})`);
		if (connectionTried>2) return; //Don't bother log anymore
	}
	console.error(`WebSocket ERROR: evt.data=${evt.data} wsUri=${wsUri}`);
}
//---
function onClose(evt) {
	if (connectionTried || evt.code == 1006 ) {
		if (connectionTried>50) {
			//connectionTried=0; 	// TODO #3ebe778e reconnect, buffer
			console.log("WebSocketServer: No reply. Giving up. Try reloading page later.");
		} else {
			setTimeout(	connect, 1000);
			return;
		}
	}
	
	let CloseReason = closeEvtCode.get(evt.code) ? closeEvtCode.get(evt.code) : "UNKNOWN";
	console.log(`WebSocket onClose: evt.wasClean==${evt.wasClean} evt.code==${evt.code} CloseReason: "${CloseReason}"`);

	shutDown = true; isOpen = false; websocket = null;
	//wasClean == True if the connection closed cleanly, false otherwise.
	//https://devdocs.io/dom/closeevent/code
}
//---
function connect() { // Connecting only when used.
	if (websocket) { console.warn("WebSocket already there. readyState="+["CONNECTING", "OPEN", "CLOSING", "CLOSED"][websocket.readyState]); }

	console.log("Connecting...");

	try {
		websocket = new WebSocket(wsUri);
		// Async. Unlike Java (* depending which implementation) this will automatically attempt to open the connection to the server
		// Unlike in Java (*), a websocket.send(...) right here would not work.
		// The first send(...) happens in event listener onOpen(...). This would not work in Java.
	} catch (ignore) {} //onError does job
	
	if (!connectionTried) connectionTried = 1;
	websocket.onopen = onOpen;
	websocket.onclose = onClose;
	websocket.onerror = onError;
	websocket.onmessage = onMessage;
}
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


function onMessage(evt) {
	var msg = evt.data;
	var cmd = msg.split(" ",1)[0]; // #note0
	var arg = msg.substring(cmd.length+1);
	
	switch (cmd) {
	case "/START":
		var n = parseInt(arg);
		if (isNaN(n)) {
			console.error("Not a number in "+msg);
			//TODO close websocket
			return;
		}
		if (Nr!=null && Nr!=n) console.error("LogSocket_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
		Nr = n;
		isOpen = true;
		if (nrBuffered ) { releaseNrBuffer(); }
		if (logBuffered ) { releaseLogBuffer(); }
		return;

	case "/PING":
		websocket.send("%/ LogSocket /"+Nr+" (JavaScript) is alive! "+numLggrs+" loggers created."); // TODO #495e57b8
		return;

	case "/GC":
		// TODO consistency check: arg==LogSocket.Nr ?
		if (!window.gc) {
			websocket.send("%/ LogSocket.js /"+Nr+": Garbage collection function window.gc() missing: Start Chrome with --js-flags=\"--expose-gc\" ?");
		} else {
			window.gc();
		}
		return;
		
	case "/FILTER1_ADD":
		for ( const rule of arg.split(" ")) {
			filter1.add(rule);
			filter1_applyRule(rule);
		}
		return;

	case "/CFT":
		let spl = arg.split(" ", 2);
		let arr = shortId2PromiseRslv.get(spl[0]);
		if ( arr != null ) {
			let [reslv, rejct] = arr;
			shortId2PromiseRslv.set(spl[0], null);
			reslv(spl[1]);
		}
		else  websocket.send("%/ALERT_R Button click:<br/>Promise is null!");
		return;
				
	}
	
	complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
}



// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Logger constructor >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// See Lggr.java for more/other explanations
function Lggr(rlm, lbl, i2, lblsCode, commnt, n) {
	this.realm = rlm;
	this.label = lbl;
	this.n2 = i2;     // realm+label+n2 give Logger ID, put together in this.longId

	this.nr = n;      // Counted by LogSocket. Incl. LogSocket.Nr gives short no-information ID for Listener GUI.
	                  // nr==0 : realm+label listed as stopped before creation. => no longId, shortId, no finalization registry //DEV #6cb5e491
	this.on = false;
	this.numMsgs = 0;
	this.longId;      // Long ID
	this.shortId;     // ==undefined if there is no logSocket.Nr - longId then has a preliminary value!=""
				      // if !=undefined longId is definitive
	this.comment = commnt;

	this.labelsCode = lblsCode;
	this.dontMakeKnown = false;
	this.lggrRefRcrd = null;
	

	if (n!=0) { // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		//FIXME / DEV #6cb5e491 #5dc4f4a6 breaks when nr==0. Use prototype
		this.on = true;
		makeLggrIdStrings(this);

		this.repeatCounters = new Map();
	
		this.toString = function() {return this.longId; };  // Should not be used
		
		// Logger services:
		this.log = function(msg) { if (this.on) {return log(this, msg);} };

		this.logErr = function(msg) { if (this.on) {return logErr(this, msg);} };

		this.logM = function(msg) { if (this.on) {return logM(this, msg);} };

		this.logC = function(n, logCntrID, msg) {
			// Log max. n messages as counted by counter logCntrID
			if (!this.on) { return false; }
			var count = this.repeatCounters.get(logCntrID);
			if (count==null) count=0;
			if (count < n) {
				this.repeatCounters.set(logCntrID, ++count);
				return log(this, `[${count}/${n}] ${msg}`);
			}
			return false;
		};

		// TODO logCM
		// TODO logOnce
		
		this.logPrms = function(msg) { // logCFtr in Java
			 if (this.on) return logPrms(this, msg);
			 else return Promise.resolve("");
		};
		 
		this.timerStart = function(timerName) { if (this.on) {return timerStartStop(this, timerName, true);} else {return false;} };
		this.timerStop = function(timerName) { if (this.on) {return timerStartStop(this, timerName, false);} else {return false;} };
	
		//TODO microTimer
		// ...

	} // if (n!=0) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
}
// Logger constructor <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


function finalizeLggr([realm, labelsCode]) { // TODO similar to Java, use async queue from client_lib.js
	let lblCd2LRRL = realm2labelsCode2LggrRefRcrdList.get(realm);
	let LRRL = lblCd2LRRL?.get(labelsCode);
	if (LRRL == null) {
		complain("LogSocket_ERROR_18 lggrRefRcrdList not found in realm2labelsCode2LggrRefRcrdList. realm="+realm+" labelsCode="+labelsCode.toString(2));
		return;
	}
	let DIAGNmsg = "==== WeakRef and shortId2PromiseRslv cleanup: ";

	let cmdArgList = [];
	LRRL = LRRL.filter( (rcrd) => {
		if (rcrd.wref.deref()==null) {
			let shortId = "/"+Nr+"_"+rcrd.nr;
			DIAGNmsg += " "+shortId;
			shortId2PromiseRslv.delete(shortId);
			if (rcrd.madeKnown) {
				// #5f5d8a51
				// makeKnown() has sent !NEW_LGGR. Now !GC_LGGR is due:
				// !GC_LGGR args for later use. We hold the lock on lggrRefRcrdList as shortly as possible
				let rlm = rcrd.longIdX.split("#",1)[0];
				cmdArgList.push( `${shortId} ${rlm}/${Nr}${rcrd.longIdX.substring(rlm.length)}` );
				// A "longIdX" that can have ";0" at the end unlike longId #66f78f43
				DIAGNmsg += "*";
			}
			return false;
		}
		return true;
	});
	lblCd2LRRL.set(labelsCode, LRRL);

	if (isOpen) {
		cmdArgList.forEach( (str) => {
			websocket.send("!GC_LGGR " + str);
		});
	}
	console.log(DIAGNmsg);
}


function makeLggrIdStrings(lgr) { 
	if ( lgr.shortId!=undefined) {return;}
	if ( lgr.n2!=0 ) { lgr.longId = `${lgr.realm}/${Nr}${lgr.label};${lgr.n2}`;
	} else           { lgr.longId = `${lgr.realm}/${Nr}${lgr.label}`; }

	if (Nr) lgr.shortId = `/${Nr}_${lgr.nr}`;
}


function makeKnown(lgr) {
	if (lgr.dontMakeKnown) return;
	try {
		websocket.send(`!NEW_LGGR ${lgr.labelsCode.toString(16)} ${lgr.on?"1":"0"} ${lgr.shortId} ${lgr.longId} ${(lgr.comment!=null ? lgr.comment : "")}`); // see also GC_LGGR
		lgr.lggrRefRcrd.madeKnown = true;
		
	} catch (e) { // TODO not catching websocket.send!
		console.error("LogSocket_ERROR_5 Exception: ", e);
		lgr.comment = "LogSocket_ERROR_5";
		lgr.on = false;
		shutDown = true; isOpen = false;
	}
}


function releaseNrBuffer() {
	if (Nr==null) { throw "LogSocket_ERROR_15: FATAL BUG. Nr should not be null"; }
	if (!nrBuffered) return;
	nrBuffered = false;
	while (nrBuffer.length!=0) {
		let bffrdLggr = nrBuffer.shift();
		bffrdLggr.comment += " [NR_BUF]";
		makeLggrIdStrings(bffrdLggr);
		makeKnown(bffrdLggr);
	}
}


function notBuffered(lgr, msg) {
	if (Nr == undefined) {
		logBuffer.push( [lgr, msg ] ); // TODO flag, sysT_ms
		logBuffered = true;
		return false;
	}

	if (logBuffered) releaseLogBuffer();
	// The Nr==null problem concerned every Lggr of this LogSocket, so
	// the ordering remains correct for all messages of this LogSocket ONLY.

	return true;
}


function releaseLogBuffer() {
	logBuffered = false;
	while ( logBuffer.length!=0 ) {
		let pair = logBuffer.shift();
		let bffrdLggr = pair[0];
		makeLggrIdStrings(bffrdLggr);
		websocket.send(`-${bffrdLggr.longId}&${bffrdLggr.shortId}&${++bffrdLggr.numMsgs}&B ${pair[1]}`); // #c29e692
	}
}

	
function complain(txt) {
	console.error("!!-- "+txt);
	try {
		websocket.send("%/ERROR /"+Nr+" "+txt);
	} catch (e) {
		// Maybe that was the reason for the complaint
	}

}
	

// Logging services: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// TODO JS microtimer reports 

function log(lgr, msg) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}
	if ( notBuffered(lgr, msg) ) {	websocket.send(`.*${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs} ${msg}`); }
	return true;
}

function logM(lgr, msg) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}
	if ( notBuffered(lgr, msg) ) {	websocket.send(`.+${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs} ${msg}`); }
	return true;
}

function logErr(lgr, msg) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}
	if ( notBuffered(lgr, msg) ) {	websocket.send(`.+${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs}&E ${msg}`); }
	return true;
}

function logPrms(lgr, msg) { // logCFtr in LogSocket.java
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return Promise.reject(new Error("LogSocket is shut down."));
	}
	if (Nr != null) { // not buffering
		let arr = shortId2PromiseRslv.get(lgr.shortId);  // shortId2CFuture in LogSocket.java
		if ( arr != null ) {
			let [reslv, rejct] = arr;
			rejct(new Error("logPrms: Old Promise rejected in favour of a new one."));
		}
		prms = new Promise( (resolve, reject) => { shortId2PromiseRslv.set(lgr.shortId, [resolve, reject]); });
		websocket.send( `.+${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs}&P ${msg.split("\n",1)[0]}\n/CFT ${lgr.shortId}` );
			// Here (not elswhere) we make sure there are no \n in msg
			// /CFT ... is the command used in client response, which adds the HTML value of the clicked button
		return prms;
	}
	return Promise.reject(new Error("LogSocket is buffering."));
}




// Global timers managed by LogSocketServer
function timerStartStop(lgr, timerName, start) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		isOpen = false;
		return false;
	}
	const msg = (start ? "!T_START " : "!T_STOP ") + timerName;
	if ( notBuffered(lgr, msg) ) { websocket.send( msg );}
	return true;
}


function sendCmd(lgr, cmd) { // TODO JS microtimer reports 
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		isOpen = false;
		return false;
	}
	if ( notBuffered(lgr, cmd) ) { websocket.send(cmd);	}
	return true;
}


const closeEvtCode = new Map(); // Eextended version in NOTES.txt #4b98b431
closeEvtCode.set(1000, "Normal Closure");
closeEvtCode.set(1001, "Going Away");
closeEvtCode.set(1002, "Protocol error");
closeEvtCode.set(1003, "Unsupported Data");
closeEvtCode.set(1004, "Reserved");
closeEvtCode.set(1005, "No Status Rcvd");
closeEvtCode.set(1006, "Abnormal Closure");
closeEvtCode.set(1007, "Invalid frame payload data");
closeEvtCode.set(1008, "Policy Violation");
closeEvtCode.set(1009, "Message Too Big");
closeEvtCode.set(1010, "Mandatory Extension");
closeEvtCode.set(1011, "Internal Error");
closeEvtCode.set(1012, "Service Restart"); //Not working, 1001 instead
closeEvtCode.set(1013, "Try Again Later");
closeEvtCode.set(1014, "Bad Gateway");
closeEvtCode.set(1015, "TLS handshake");

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// >>> Filter >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Using names from corresponding file Filter.java, even if odd here

var rulesUniq = new Map();
var realm2labelsCode2RuleResult = new Map();

var label2Nr = new Map();
var labelsCode2NumBits = new Map();
var nextLabelNr = 1n;


class RuleLR { // Java record
	constructor(realm, labels, labelsCode, result) {
		this.realm=realm; this.labels=labels; this.labelsCode=labelsCode; this.result=result;
	}
	realm; labels; labelsCode; result;
	toRuleRStr() { return `${this.realm}>${this.labels==null?"*":this.labels.join("^")}=${this.result}`; }
	toRuleuniqStr() { return `${this.realm}${this.labels==null?"":this.labels.join("")}`; }
	toString() { return `${this.toRuleRStr()} labelsCode=${this.labelsCode.toString(2)}`; }
}

class ErsatzSkipListMap extends Map {
	constructor(comprtr){super();this.comparator=comprtr;}
	#comparator;
	#keys = [];
	#sorted = false;
	set(k,v) {
		if (!super.has(k)) { this.#keys.push(k); this.#sorted = false; }
		super.set(k,v);
	}
	keySetforEach(callBack) {
		if (!this.#sorted) { this.#keys.sort(this.#comparator); this.#sorted = true; }
		this.#keys.forEach(callBack)
	}
}


function Filter_registerLabels(labelsStream) {
	var labelsCode = 0n; // long integer labelsCode #681a8b4e
	var sublabelNr = 0n;
	var numBits = 0;
	
	for (const lbl of labelsStream.sort().filter( (el,indx,arr) => !indx || el!=arr[indx-1] ) ) {
		if ( null==(sublabelNr=label2Nr.get(lbl)) ) {
			label2Nr.set(lbl, nextLabelNr); console.log("DIAGN label2Nr.put("+lbl+", "+nextLabelNr.toString(2)+")" );
			labelsCode = labelsCode | nextLabelNr;
			nextLabelNr = nextLabelNr << 1n
			// TODO throw error at Java -9223372036854775808L
		} else {
			labelsCode = labelsCode | sublabelNr;
		}
		numBits++;
	}
	labelsCode2NumBits.set(labelsCode, numBits);
	
	return labelsCode;
}

function labelsCodeComparator(l1,l2) { // Sort by specificity #1ab76b52
	let b1=labelsCode2NumBits.get(l1), b2=labelsCode2NumBits.get(l2);
	if ( b1==null || b2==null ) { b1=0; b2=0; throw new Error("BUG: ConcurrentSkipListMap comparator: labelsCode2NumBits gives null."); }
	return b1!=b2 ? Math.sign(b1-b2) : (l1<l2 ? -1 : l1>l2 ? 1 : 0); // no Math.sign for BigInt
}

function Filter_parseRuleStringAndStore(ruleRStr) {
	let labelsCode = 0n;
	let a = ruleRStr.indexOf('>');
	let b = ruleRStr.indexOf('=');
	// Bug safety:
	if (a<1) throw new Error("Filter_parseRuleString("+ruleRStr+") Error1");
	if (b==-1) throw new Error("Filter_parseRuleString("+ruleRStr+") Error2");
	if (b==ruleRStr.length()-1) throw new Error("Filter_parseRuleString("+ruleRStr+") Error3");
	// Split labels and register:
	let lblL = null;
	if (ruleRStr.charAt(a+1)=='*') {
		labelsCode = 0n;
	} else {
		if (ruleRStr.charAt(a+1)!='#') throw new Error("Filter_parseRuleString("+ruleRStr+") Error4");
		lblL = ruleRStr.substring(a+1, b).split("^").sort();
		labelsCode = Filter_registerLabels( lblL.map( (s) => s.substring(1) ) );
	}

	// New rule:
	let result = ruleRStr.substring(b+1);
	let realm = ruleRStr.substring(0, a);
	ruleLR = new RuleLR(realm, lblL, labelsCode, result	);
	// really new?
	let ruleuniqStr = ruleLR.toRuleuniqStr();
	if ( rulesUniq.has(ruleuniqStr) )  throw new Error("Filter: "+ruleuniqStr+" already exists: "+ruleLR.toRuleRStr());
	rulesUniq.set(ruleuniqStr, ruleLR.result);
	
	//Register rule:
	let labelsCode2RuleResult = realm2labelsCode2RuleResult.get(ruleLR.realm);
	if (null==labelsCode2RuleResult) {
		labelsCode2RuleResult = new ErsatzSkipListMap(labelsCodeComparator);
		realm2labelsCode2RuleResult.set(ruleLR.realm, labelsCode2RuleResult);
	}
	labelsCode2RuleResult.set(labelsCode, ruleLR.result);
		
	return ruleLR;
}


function filter(realm, labelsCode) {
console.error("TODO filter()", realm, labelsCode);
	
}




var ruleResult2cmd = new Map([["M", "!SILENCED"], ["E", "%IGNORED"]]); // no spaces unlike Java
//---
function applyRule2lggrs(ruleLR) {
console.log("== DIAGN applyRule2lggrs "+ruleLR.toString());
	if ( ruleLR.labels==null ) {
		complain("TODO #6776bf39 filter1 rule="+ruleLR.toString());
		websocket.send("%/ALERT_R TODO #6776bf39 Filter:<br/>"+escapeHTML(ruleLR.toRuleRStr()));
		return;
	}

	var realms; // Either a map iterator object or a 1-element array
	if ( ruleLR.realm=="*" ) {
		 realms = realm2labelsCode2LggrRefRcrdList.keys();
		 // Hahaha... if (realms.isEmpty()) return;
	} else {
		realms = [ruleLR.realm];
	}
	
	let resultIsE = "E".equals(ruleLR.result);
	let joiner = "";
	let DIAGNfltrdNum = 0;
	let DIAGNalreadyfltrdNum = 0;
	let DIAGNgoneNum = 0;
	
	for(let realm in realms) {
		let labelsCode2lggrRefRcrdList = realm2labelsCode2LggrRefRcrdList.get(realm);
		for(let labelsCode in labelsCode2lggrRefRcrdList.keys()) {
			if ( (labelsCode & ruleLR.labelsCode) == ruleLR.labelsCode ) {
				for(let rcrd in labelsCode2lggrRefRcrdList.get(labelsCode)) {
					let l = rcrd.wref.deref();
					if ( l!=null ) {
console.log("=== DIAGN applyRule2lggrs realmlabel=="+l.realm+l.label+" longIdX=="+rcrd.longIdX);
						if ( l.on ) {
							l.on=false;
							DIAGNfltrdNum++;
							filteredRealmLabel.put(l.realm+l.label, ruleLR.result);
						} else {
							//----------------------------------
							if (TEST1) {
								if ( filteredRealmLabel.has(l.realm+l.label) ) {
									console.error("**** LogSocket.Filter TEST1.B: BUG! LogSocket.filteredRealmLabel.containsKey(\""+l.realm+l.label+"\") == false");
								}
							}
							//----------------------------------
							DIAGNalreadyfltrdNum++;
						}
						if (resultIsE) l.dontMakeKnown = true;
						if (rcrd.madeKnown) joiner += ` ${l.shortId}`;

					}  else {
						DIAGNgoneNum++;
console.log("=== DIAGN applyRule2lggrs longIdX=="+rcrd.longIdX);
					}
				}
			}
		}
	}
	
	if (joiner!="") websocket.send(ruleResult2cmd.get(ruleLR.result) + joiner);
	websocket.send(`%/DIAGN LogSocket /${LogSocket.Nr}: Filter rule "${ruleLR.toRuleRStr()}" stopped ${DIAGNfltrdNum} logger instance${(DIAGNfltrdNum==1?"":"s")} - ${DIAGNalreadyfltrdNum} already stopped, ${DIAGNgoneNum} gone.`);
	websocket.send(`%/ALERT_B Filter: Stopped ${DIAGNfltrdNum}`
		+((DIAGNalreadyfltrdNum[0]!=0) ? `<br/>${DIAGNalreadyfltrdNum} already stopped.` : "")
	);
}


// <<< Filter <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// Assign to global var LogSocket:
return 	{ 
	newLggr: // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
function(realm, label, comment) {
	if (!websocket) connect();

	if( comment==undefined ) comment="";
	
	let checkedLabel = label;
	if( label==undefined || label=="" ) {
		checkedLabel = "#NOLABEL";
	} else if ( label.at(0)!="#" ) {
		checkedLabel = "#"+label; //else bug!
	}
	
	let checkedRealm = realm.replaceAll(illglRlmChrsPttrn, "");
	if (checkedRealm=="")  checkedRealm="Errr"; 
	let checkedRealmLabel = checkedRealm + (checkedLabel=checkedLabel.replaceAll(illglLblChrsPttrn, "")); 

	var filtered;
	if ( "E"==( filtered=filteredRealmLabel.get(checkedRealmLabel) ) ) {
		console.log("newLggr pre-FILTERED \"E\" on creation: "+checkedRealm+" "+checkedLabel+" "+comment+( checkedRealmLabel==(realm+label) ? "" : " [REAL/LABEL CORRECTED]" ));  //DIAGN
		return new Lggr(realm, checkedLabel, 0, 0n, "", 0);
	}

	let labelsCode = Filter_registerLabels(checkedLabel.substring(1).split("#"));


	// ----------------------

	// Duplicate?

	let lastLggrN2 = realmLabel2lastLggrN2.get(checkedRealmLabel);
	let n2 = (lastLggrN2==null ? 0 : lastLggrN2+1);
	realmLabel2lastLggrN2.set(checkedRealmLabel, n2);

	let newLggr = new Lggr(
		checkedRealm, checkedLabel,
		n2,
		labelsCode,
		( comment = comment.trim()+( checkedRealmLabel==realm+label ? "" : " [REALM/LABEL CORRECTED]" ) ),
		++numLggrs
	);
	newLggr.on = !(filtered=="M"); // "M" == ignore messages

	let lRR = new LggrRefRcrd(checkedRealmLabel+";"+n2, numLggrs, false, new WeakRef(newLggr) );
	newLggr.lggrRefRcrd = lRR;
	
	// Add to data structure for filter...
	let lggrRefRcrdList = null;
	let labelsCode2LggrRefRcrdList = realm2labelsCode2LggrRefRcrdList.get(checkedRealm);
	if (null==labelsCode2LggrRefRcrdList) {
		labelsCode2LggrRefRcrdList = new Map();
		lggrRefRcrdList = [lRR];
		realm2labelsCode2LggrRefRcrdList.set(checkedRealm, labelsCode2LggrRefRcrdList);
		labelsCode2LggrRefRcrdList.set(labelsCode, lggrRefRcrdList);
	} else {
		lggrRefRcrdList = labelsCode2LggrRefRcrdList.get(labelsCode);
		if (null==lggrRefRcrdList) {
			lggrRefRcrdList = [lRR];
			labelsCode2LggrRefRcrdList.set(labelsCode, lggrRefRcrdList);
		} else {
			lggrRefRcrdList.push(lRR);
		}
	}
	
	// ... which later needs to be cleaned up / finalized:
	finalizeRgstr.register(newLggr, [checkedRealm, labelsCode] );

	// Going public:
	if (Nr==null) { // E.g. websocket not yet ready
		nrBuffer.push(newLggr);
		nrBuffered = true;
	} else { // Since Nr exists, websocket works (except glitch)
		makeKnown(newLggr);
	}
	
	console.log("newLggr on="+newLggr.on+" "+labelsCode.toString(2)
		+" "+newLggr.shortId+" "+newLggr.realm+" "+newLggr.label+" "+newLggr.comment
	); //DIAGN

	return newLggr;
}, // function newLggr <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
	closeEvtCode: closeEvtCode
};
// END of var LogSocket = ( () => { ...	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
})();
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



// General use utils >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// https://stackoverflow.com/questions/11547672/how-to-stringify-event-object
LogSocket.stringify = function(object, depth=0, max_depth=5) {

	if (depth > max_depth) return 'Object';

	const obj = {};
	for (let key in object) {
		let value = object[key];
		if (value instanceof Node)
			// specify which properties you want to see from the node
			value = { id: value.id };
		else if (value instanceof Window) value = 'Window';
		else if (value instanceof Object) value = LogSocket.stringify(value, depth + 1, max_depth);
		obj[key] = value;
	}

	return depth ? obj : JSON.stringify(obj);
}

// https://stackoverflow.com/a/66481918/3123382
LogSocket.escapeHTML = function(unsafe) {
	return unsafe.replace(
		/[\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u00FF]/g,
		c => '&#' + ('000' + c.charCodeAt(0)).slice(-4) + ';'
	);
}
