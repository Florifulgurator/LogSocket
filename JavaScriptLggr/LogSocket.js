/**
 *  LogSocket.js
 *  1-File parallel to 2-File LogSocket.java, Lggr.java
 *  An exercise in comparative JS/Java linguistics :-)
 */

if ( typeof LogSocket != "undefined" ) throw "LogSocket already exists";

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LogSocket = ( () => {
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Instead of using an object literal with tons of this.xy we use the closure
// of an anonymous immediately invoked function.

const debug = false; // console.log messages on/off

// Private local variables and functions, visible to Lggr objects:
var Nr;  // Unique ID generated by LogSocketServer & set via "/START Nr"
var uri = "ws://localhost:8080/logsocket/ws"; // LogSocketServer URI HARDWIRED #57977fd8
var websocket;
var shutDown = false;
var isOpen = false;
var numLggrs = 0;	//Count of created Loggers.
var realmLabel2LggrList = new Map();
var logBuffer = [];
var logBuffered = false;
var nrBuffer = [];
var nrBuffered = false;
var filter1 = new Set(); //DEV #6cb5e491

const illglLblChrsPttrn = new RegExp("[^#@A-Za-z0-9_]", "g");

const finalizeRgstr = new FinalizationRegistry( val => {finalizeLggr(val);} ); // Lggr garbage collection


function onOpen(evt) {
	isOpen = true;
	websocket.send("!GREETS");
}
//---
function onClose(evt) { // #3ebe778e TODO reconnect after timeout, buffer
	isOpen = false;
	let CloseReason = closeEvtCode.get(evt.code) ? closeEvtCode.get(evt.code)[0] : "UNKNOWN";
	console.log(`WebSocket onClose: evt.wasClean==${evt.wasClean} evt.code==${evt.code} CloseReason: "${CloseReason}"`);

	shutDown = true;
	//wasClean == True if the connection closed cleanly, false otherwise.
	//https://devdocs.io/dom/closeevent/code
}
//---
function onError(evt) {
	// If an error occurs while attempting to connect, first a simple event with the name error is sent to the WebSocket object (thereby invoking its onerror handler),
	// and then the CloseEvent is sent to the WebSocket object (thereby invoking its onclose handler) to indicate the reason for the connection's closing.
}
//---
function onMessage(evt) {
	var msg = evt.data;
	var cmd = msg.split(" ",1)[0]; // #note0
	var arg = msg.substring(cmd.length+1);
	
	switch (cmd) {
	case "/START":
		var n = parseInt(arg);
		if (isNaN(n)) {
			console.error("Not a number in "+msg);
			//TODO close websocket
			return;
		}
		if (Nr!=null && Nr!=n) console.error("LogSocket_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
		Nr = n; //TODO or not TODO cf. Java
		if (nrBuffered ) { releaseNrBuffer(); }
		if (logBuffered ) { releaseLogBuffer(); }
		return;

	case "/PING":
		websocket.send("/PING LogSocket /"+Nr+" is alive! "+numLggrs+" loggers created."); // TODO #495e57b8
		return;

	case "/GC":
		// TODO consistency check: arg==LogSocket.Nr ?
		if (!window.gc) {
			websocket.send("/GC LogSocket /"+Nr+": Garbage collection function window.gc() missing: Start Chrome with --js-flags=\"--expose-gc\" ?");
		} else {
			window.gc();
		}
		return;
		
	case "/FILTER1_ADD":
		for ( const rule of arg.split(" ")) {
			filter1.add(rule);
			filter1_applyRule(rule);
		}
		return;
				
	}
	
	complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
}

	
function connect() { // Connecting only when used.
	if (websocket) { console.error("WebSocket already there."); return; }
	websocket = new WebSocket(uri); // Async. Unlike Java (depending which implementation) this will automatically attempt to open the connection to the server
	websocket.onopen = onOpen;
	websocket.onclose = onClose;
	websocket.onerror = onError;
	websocket.onmessage = onMessage;
	console.log("LogSocket connect()");
	// Unlike in Java, a websocket.send(...) right here would not work:
	// >> Failed to execute 'send' on 'WebSocket': Still in CONNECTING state. <<
	// The first send(...) happens in event listener onOpen(...). This would not work in Java.
}


// Logger constructor & finalize >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// See lggr.java for more explanations
// TODO: check if called with new
function Lggr(rlm, lbl, i2, commnt, n) {
	this.realm = rlm;
	this.label = lbl;
	this.n2 = i2;     // realm+label+n2 give Logger ID, put together in this.longId
	this.nr = n;      // Counted by LogSocket. Incl. LogSocket.Nr gives short no-information ID for Listener GUI.
	                  // nr==0 : realm+label listed as stopped before creation. => no longId, shortId, no finalization registry //DEV #6cb5e491
	this.on = false;
	this.numMsgs = 0;
	this.longId;      // Long ID
	this.shortId;     // ==undefined if there is no logSocket.Nr - longId then has a preliminary value!=""
				      // if !=undefined longId is definitive
	this.comment = commnt;

	if (n!=0) { // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		this.on = true;
		makeLggrIdStrings(this);

		this.repeatCounters = new Map();
	
		this.toString = function() {return this.longId; };  // Should not be used
		
		this.log = function(msg) { if (this.on) {return log(this, msg);} };
	
		this.logC = function(n, logCntrID, msg) {
			// Log max. n messages as counted by counter logCntrID
			// When max, stop logger (incl. duplicates TODO #492fd0a4)
			if (!this.on) { return false; }
			var count = this.repeatCounters.get(logCntrID);
			this.repeatCounters.set(logCntrID, (count ? ++count : (count=1)));
			let rtrn = log(this, `[${count}/${n}] ${msg}`);
			if (count >= n) stopLggr(realm+label); //TODO #492fd0a4 stop individual
			return rtrn;
		};
		 
		this.timerStart = function(timerName) { if (this.on) {return timerStartStop(this, timerName, true);} else {return false;} };
		this.timerStop = function(timerName) { if (this.on) {return timerStartStop(this, timerName, false);} else {return false;} };
	
		// ...
		//TODO more functions from Java
	} // if (n!=0) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
}
//---
function finalizeLggr(str) {
	if (!isOpen) return;
	websocket.send("/GC Finalizing Logger "+str); 
	websocket.send("!GC_LGGR " + str);
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


function makeLggrIdStrings(lgr) { 
	if ( lgr.shortId!=undefined) {return;}
	if ( lgr.n2!=0 ) { lgr.longId = `${lgr.realm}/${Nr}${lgr.label};${lgr.n2}`;
	} else           { lgr.longId = `${lgr.realm}/${Nr}${lgr.label}`; }

	if (Nr) {
		lgr.shortId = `/${Nr}_${lgr.nr}`;
	}
}

function makeKnown(lgr) {
	try {
		if (!isOpen) throw "Websocket not ready";

		finalizeRgstr.register(lgr, `${lgr.shortId} ${lgr.longId}`);
		websocket.send(`!NEW_LGGR ${lgr.on?"1":"0"} ${lgr.shortId} ${lgr.longId} ${(lgr.comment!=null ? lgr.comment : "")}`); // see also GC_LGGR
		lgr.ignore = false;

	} catch (e) { // TODO not catching websocket.send!
		console.error("---- LogSocket_ERROR_5 Exception: ", e);
		lgr.comment = "LogSocket_ERROR_5";
		lgr.on = false;
		shutDown = true;
		return false;
	}
	return true;
}


function releaseNrBuffer() {
	if (Nr==null) { throw "LogSocket_ERROR_15: FATAL BUG. Nr should not be null"; }
	if (!nrBuffered) return;
	nrBuffered = false;
	while (nrBuffer.length!=0) {
		let bffrdLggr = nrBuffer.shift();
		bffrdLggr.comment += " [NR_BUF]";
		makeLggrIdStrings(bffrdLggr);
		makeKnown(bffrdLggr);
	}
}


function notBuffered(lgr, msg) {
	if (Nr == undefined) {
		logBuffer.push( [lgr,msg] );
		logBuffered = true;
		return false;
	}

	if (logBuffered) {
		// The Nr==null problem concerned every Lggr. 
		releaseLogBuffer();
	}
	return true;
}

function releaseLogBuffer() {
	logBuffered = false;
	while ( logBuffer.length!=0 ) {
		let pair = logBuffer.shift();
		let bffrdLggr = pair[0];
		makeLggrIdStrings(bffrdLggr);
		websocket.send(`~${bffrdLggr.longId}&${bffrdLggr.shortId}&${++bffrdLggr.numMsgs}&B ${pair[1]}`); // #c29e692
	}
}

	
function complain(txt) {
	console.error("!!-- "+txt);
	try {
		websocket.send("/ERROR /"+Nr+" "+txt);
	} catch (e) {
		// Maybe that was the reason for the complaint
	}

}
	
// Logging services: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// TODO logM, logErr, logCmd from Java

function log(lgr, msg2) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		isOpen = false;
		return false;
	}
	if ( notBuffered(lgr, msg2) ) {	websocket.send(`*${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs} ${msg2}`); }
	return true;
}


// Global timers managed by LogSocketServer
function timerStartStop(lgr, timerName, start) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		isOpen = false;
		return false;
	}
	const msg = (start ? "!T_START " : "!T_STOP ") + timerName;
	if ( notBuffered(lgr, msg) ) { websocket.send( msg );}
	return true;
}


function sendCmd(lgr, cmd) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		isOpen = false;
		return false;
	}
	if ( notBuffered(lgr, cmd) ) { websocket.send(cmd);	}
	return true;
}


function filter1_applyRule(realmLabel) {
	
	if (realmLabel.charAt(0)=='*') {//All realms
		complain("TODO #6776bf39 filter1 rule="+realmLabel);
		return;
	}
	if (realmLabel.charAt(realmLabel.length-1)=='*') {//All labels
		complain("TODO #6776bf39 filter1 rule="+realmLabel);
		return;
	}

	let lggrList = realmLabel2LggrList.get(realmLabel);
	if (lggrList==null) return;

	let cmdArgs="";
	let gone=0, stopped=0, alreadystopped=0;
	
	for (weakRef of lggrList) {
		let l = weakRef.deref();
		if ( l!=null ) {
			if ( l.on ) {
				l.on=false;
				stopped++;
			} else {
				alreadystopped++;
			}
			cmdArgs += " "+l.shortId;
			
		} else gone++;
	}
	
	if ( cmdArgs!="" ) {
		websocket.send("!STOPPED"+cmdArgs );
		websocket.send("/ "+"LogSocket /"+Nr+": Filter rule \""+realmLabel+"\" stopped "+stopped+" logger instance"+(stopped==1?"":"s")
	                +" - "+alreadystopped+" already stopped, "+gone+" gone." );
		//TODO #7594d994 client consistency test
	}
}

	
const closeEvtCode = new Map();
closeEvtCode.set(1000, ["Normal Closure", "The connection successfully completed the purpose for which it was created."]);
closeEvtCode.set(1001, ["Going Away", "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."]);
closeEvtCode.set(1002, ["Protocol error", "The endpoint is terminating the connection due to a protocol error."]);
closeEvtCode.set(1003, ["Unsupported Data", "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"]);
closeEvtCode.set(1004, ["Reserved", "Reserved. A meaning might be defined in the future."]);
closeEvtCode.set(1005, ["No Status Rcvd", "Reserved. Indicates that no status code was provided even though one was expected."]);
closeEvtCode.set(1006, ["Abnormal Closure", "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."]);
closeEvtCode.set(1007, ["Invalid frame payload data", "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."]);
closeEvtCode.set(1008, ["Policy Violation", "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."]);
closeEvtCode.set(1009, ["Message Too Big", "The endpoint is terminating the connection because a data frame was received that is too large."]);
closeEvtCode.set(1010, ["Mandatory Ext.", "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."]);
closeEvtCode.set(1011, ["Internal Error", "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."]);
closeEvtCode.set(1012, ["Service Restart", "The server is terminating the connection because it is restarting."]);
closeEvtCode.set(1013, ["Try Again Later", "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."]);
closeEvtCode.set(1014, ["Bad Gateway", "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."]);
closeEvtCode.set(1015, ["TLS handshake", "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."]);

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// Assign to global var LogSocket:
return 	{ 
	newLggr: function(realm, label, comment) {
		if (!websocket) connect();

		if( comment==undefined ) comment="";
		
		let checkedLabel = label;
		if( label==undefined || label=="" ) {
			checkedLabel = "#NOLABEL";
		} else if ( label.at(0)!="#" ) {
			checkedLabel = "#"+label; //else bug!
		}
		checkedLabel = checkedLabel.replaceAll(illglLblChrsPttrn, ""); // remove whitespace, "/", "."

		if ( filter1.has(realm+checkedLabel) ) { //DEV #6cb5e491
			return new Lggr(realm, checkedLabel, 0, "", 0);
		}

		let lggrList = realmLabel2LggrList.get(realm+checkedLabel);
		let n2;
		if ( lggrList === void null ) {
			realmLabel2LggrList.set(realm+checkedLabel, (lggrList=[]) );
			n2 = 0;
		} else {
			n2 = lggrList.length;
		}

		let newLggr = new Lggr(realm, checkedLabel, n2, comment.trim()+( checkedLabel==label ? "" : " [LABEL CORRECTED]" ), ++numLggrs);
		lggrList.push(new WeakRef(newLggr));
		
		if (Nr==null) { // E.g. websocket not yet ready
			nrBuffer.push(newLggr);
			nrBuffered = true;
		} else { // Since Nr exists, websocket works (except glitch)
			makeKnown(newLggr);
		}
		
		return newLggr;
	}
};
// END of var LogSocket = ( () => { ...	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
})();
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



// Gereneral use utils >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// https://stackoverflow.com/questions/11547672/how-to-stringify-event-object
LogSocket.stringify = function(object, depth=0, max_depth=5) {

	if (depth > max_depth) return 'Object';

	const obj = {};
	for (let key in object) {
		let value = object[key];
		if (value instanceof Node)
			// specify which properties you want to see from the node
			value = { id: value.id };
		else if (value instanceof Window) value = 'Window';
		else if (value instanceof Object) value = LogSocket.stringify(value, depth + 1, max_depth);
		obj[key] = value;
	}

	return depth ? obj : JSON.stringify(obj);
}


