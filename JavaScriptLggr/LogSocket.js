/**
 *  LogSocket.js  October 2023
 *  Some Old Javascript style, to see the language foundation.
 *  New Javascript things when convenient or necessary, like FinalizationRegistry.
 */

if ( typeof LogSocket != "undefined" ) throw "LogSocket already exists";

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
LogSocket = ( () => {
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Instead of using an object literal with tons of this.xy we use the closure
// of an anonymous immediately invoked function.

var debug = false; // console.log messages on/off

// Private local variables and functions, visible to Lggr objects:
var Nr;  // Unique ID generated by LogSocketServer & set via "/START Nr"
var uri = "ws://localhost:8080/logsocket/ws";
var websocket;
var isClosed = false;
//var sezs = "RndmWndw@"+Math.round(Math.random()*1679616).toString(36).padStart(4,"0");
// RndmWndw@... instead of WsSession@cafebabe in LogSocket.java. Not seriously needed

var numLggrs = 222;	//Count of created Loggers. 222 = debug nr
var realmLabel2lastLggrN2 = {};
var logBuffer = [];
var logBuffered = false;
var nrBuffer = [];
var nrBuffered = false;

var finalizeRgstr = new FinalizationRegistry( val => {finalizeLggr(val);} ); // Lggr garbage collection


function onOpen(evt) {
	websocket.send("!GREETS");
}
function onClose(evt) {	
	isClosed = true; // For logger performance
	//wasClean == True if the connection closed cleanly, false otherwise.
	//https://devdocs.io/dom/closeevent/code
}
function onError(evt) {
	// Generic Event. No additional properties documented at
	// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event.
}
function onMessage(evt) {
	var cmd = evt.data.split(" ",1)[0];
	
	if (cmd=="/START") {
		var n = parseInt(evt.data.substring(7));
		if (isNaN(n)) {
			console.error("Not a number in "+evt.data);
			n = 9908; // 9908 = debug nr
		}
		Nr = n; //TODO or not TODO cf. Java
		
		if (nrBuffered ) {
			releaseNrBuffer();
		}
		if (logBuffered ) {
			releaseLogBuffer();
		}

		return;
	}
	if (cmd=="/PING") {
		websocket.send("/PING LogSocket /"+Nr+" is alive!");
		return;
	}	
	if (cmd=="/GC") {
		// TODO consistency check: arg==LogSocket.Nr ?
		if (!window.gc) {
			websocket.send("/GC LogSocket /"+Nr+": window.gc() missing, garbage collection not callable: Start Chrome with --js-flags=\"--expose-gc\" ?");
		} else {
			window.gc();
		}
		return;
	}	
}
	
function connect() { // Connecting only when used.
	if (websocket) { console.error("WebSocket already there."); return; }
	websocket = new WebSocket(uri); // Unlike Java (depending which implementation) this will automatically attempt to open the connection to the server
	websocket.onopen = onOpen;
	websocket.onclose = onClose;
	websocket.onerror = onError;
	websocket.onmessage = onMessage;
	// Unlike in Java, a websocket.send(...) right here would not work:
	// >> Failed to execute 'send' on 'WebSocket': Still in CONNECTING state. <<
	// We have to wait for Javascript to pause, so the websocket handshake can complete.
	// The first send(...) happens in event listener onOpen(...). This would not work in Java.
}

// Logger constructor & finalize >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Constructor TODO: check if called with new
function Lggr(rlm, lbl, i2, commnt, n) {
	// See lggr.java for more explanations
	this.realm = rlm;
	this.label = lbl;
	this.n2 = i2;  // realm+label+n2 give Logger ID, put together in this.longId
	this.nr = n;   // Counted by LogSocket. Incl. LogSocket.Nr gives short no-information ID for Listener GUI.
	this.on = true;
	this.numMsgs = 0;
	this.longId;  // Long ID
	this.shortId; // ==undefined if there is no logSocket.Nr - longId then has a preliminary value!=""
				   // if !=undefined longId is definitive
	this.comment = commnt;
	this.repeatCounters = {};

	makeLggrIdStrings(this);

	this.toString = function() {return this.longId; }; //TODO Java
	
	this.log = function(msg) { if (this.on) {return log(this, msg);} };

	this.logC = function(n, logCntrID, msg) { // log max. n messages as counted by counter logCntrID
		if (!this.on) { return false; }
		var count = this.repeatCounters[logCntrID];
		this.repeatCounters[logCntrID] = ( count ? ++count : (count=1) );
		this.on = (count<n);
		return log(this, `[${count}/${n}] ${msg}`);
	};
	 
	this.timerStart = function(timerName) { if (this.on) {return timerStartStop(this, timerName, true);} else {return false;} };
	
	this.timerStop = function(timerName) { if (this.on) {return timerStartStop(this, timerName, false);} else {return false;} };

	// ...
	//TODO more functions from Java
	
}// -----
function makeLggrIdStrings(lgr) { 
	if ( lgr.shortId!=undefined) {return;}
	if ( lgr.n2!=0 ) { lgr.longId = `${lgr.realm}/${Nr}${lgr.label}.${lgr.n2}`;
	} else           { lgr.longId = `${lgr.realm}/${Nr}${lgr.label}`; }

	if (Nr) { // TODO/FIXME why if(Nr) ?
		lgr.shortId = `/${Nr}_${lgr.nr}`;
		finalizeRgstr.register(lgr, `${lgr.shortId} ${lgr.longId}`);
	}
}// -----
function finalizeLggr(str) {
	websocket.send("/GC Garbage collection: Finalizing Logger "+str);
	websocket.send("!DEL_LGGR " + str);
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


function NEW_LGGR_cmd(lgr) { // see also DEL_LGGR
		return `!NEW_LGGR ${lgr.shortId} ${lgr.longId} ${(lgr.comment!=null ? lgr.comment : "")}`;
}

function releaseNrBuffer() {
	if (Nr==null) { throw "LogSocket_ERROR_15: FATAL BUG. Nr should not be null"; }
	if (!nrBuffered) return;
	nrBuffered = false;
	while (nrBuffer.length!=0) {
		bffrdLggr = nrBuffer.shift();
		makeLggrIdStrings(bffrdLggr);
		//try {
		websocket.send(NEW_LGGR_cmd(bffrdLggr));
		//} catch (IOException e) {
		//	System.err.println("---- LogSocket_ERROR_4 IOException: "+e.getMessage());
		//}
	}
}
	
function log(lgr, msg) {
	if ( notFiltered(lgr, msg) ) {
		if ( notBuffered(lgr, msg) ) {
			websocket.send(`*${lgr.longId}&${lgr.shortId}&${++lgr.numMsgs} ${msg}`);
		}
		return true;
	}
	return false;
}

function timerStartStop(lgr, timerName, start) {
		const msg = (start ? "!T_START " : "!T_STOP ") + timerName;
		if ( notFiltered(lgr, msg) ) {
			if ( notBuffered(lgr, msg) ) {
				websocket.send( msg );
			}
			return true;
		} 
		return false;
	}

function notFiltered(lgr, msg) {
	// First fast step of filtering >>>>>>>>>
	if ( isClosed ) {
		//TODO serverClosed ?
		 return false;
	}
	//if ( ignoreLggrNr.contains(lgr.nr) ) {	return false;	}
	// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//TODO Server-side filter of unwanted log messages.
	//     (TODO Client-side filter.)
	filtered=false;
	// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	if (filtered) { return false; }
	return true;
}
//---
function notBuffered(lgr, msg) {
	if (Nr == undefined) {
		logBuffer.push( [lgr,msg] );
		logBuffered = true;
		return false;
	}

	if (logBuffered) {
		// The Nr==null problem concerned every Lggr. 
		releaseLogBuffer();
	}
	return true;
}
//---
function releaseLogBuffer() {
	if (Nr==null) { throw "LogSocket_ERROR_14: FATAL BUG. Nr should not be null"; }

	logBuffered = false;
	while ( logBuffer.length!=0 ) {
		pair = logBuffer.shift();
		bffrdLggr = pair[0];
		makeLggrIdStrings(bffrdLggr);
		websocket.send(`~${bffrdLggr.longId}&${bffrdLggr.shortId}&${++bffrdLggr.numMsgs}&B ${pair[1]}`); // #c29e692
	}
}
	

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// Assign to global var LogSocket:
return 	{ 
	newLggr: function(realm, label, comment) {
		if (!websocket) connect();

		if( comment==undefined ) comment="";
		if( label==undefined || label=="" ) {
			label="#INFO";
		} else if ( label.at(0)!="#" ) {
			label = "#"+label; //else bug!
			//TODO complain
		}
		
		// TODO realms.add(realm);

		var lastLggrN2 = realmLabel2lastLggrN2[realm+label];
		var n2;

		if ( lastLggrN2==undefined ) {
			n2 = 0;
		} else {
			n2 = lastLggrN2 + 1;
		}

		var newLggr = new Lggr(realm, label, n2, comment.trim(), numLggrs++);

		realmLabel2lastLggrN2[realm+label] = newLggr.n2; 

		if (Nr==null) { // E.g. websocket not yet ready
			nrBuffer.push(newLggr);
			nrBuffered = true;
		} else {
			websocket.send(NEW_LGGR_cmd(newLggr)); // Since Nr exists, websocket works
		}
		
		return newLggr;
	}
};

// END of var LogSocket = ( () => { ...	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
})();


// Gereneral use utils >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

// https://stackoverflow.com/questions/11547672/how-to-stringify-event-object
LogSocket.stringify = function(object, depth=0, max_depth=5) {

	if (depth > max_depth) return 'Object';

	const obj = {};
	for (let key in object) {
		let value = object[key];
		if (value instanceof Node)
			// specify which properties you want to see from the node
			value = { id: value.id };
		else if (value instanceof Window) value = 'Window';
		else if (value instanceof Object) value = LogSocket.stringify(value, depth + 1, max_depth);
		obj[key] = value;
	}

	return depth ? obj : JSON.stringify(obj);
}

//  serious END <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


// NOTES: --------------------------------------------------------------------
// 
// Kept on (A) reload and duplicate, always undefined on (B) fresh load:
// if ( sessionStorage.windowID == undefined ) sessionStorage.windowID="hurz!!";
//
// Java: Runtime.getRuntime().toString() changes on (B) Eclipse server restart.
//       Same in (A) different console windows.
