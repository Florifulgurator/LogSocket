package florifulgurator.logsocket.javalggr;

import florifulgurator.logsocket.utils.Tuple;

import javax.websocket.Session;


import java.io.IOException;
import java.lang.ref.WeakReference;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;
import java.util.stream.Stream;





public class LogSocket {
// Singleton: Private constructor.


static IWebSocket                        websocket = null; // WebSocketImpl1 javax.websocket // #6b31fbdc
                                                           // WebSocketImpl2 java.net.http.WebSocket
                                                           
protected static Integer                 Nr = null;  // Unique ID generated by LogSocketServer & set via "/START Nr"
private static URI                       uri = URI.create("ws://localhost:8080/logsocket/ws");  // LogSocketServer URI HARDWIRED #57977fd8
protected static boolean                 shutDown = false;

private static Integer                   numLggrs = 0;	//Count of created Loggers. Not seriously used.

private static Map<String,Integer>       realmLabel2lastLggrN2 = new ConcurrentHashMap<>();
// DOCU #681a8b4e 
// Duplicates are counted according to the labels string passed upon logger creation.
// Sub-label ordering is relevant here, but not for filtering:
// The filter mechanism uses a long integer labelsCode bit map, where sub-label ordering is irrelevant.

static Map<String, Map<Long, ArrayList<Tuple<String,WeakReference<Lggr>>>>> realm2labelsCode2LggrList = new ConcurrentHashMap<>();
// Tuple keeps a variant long logger Id (cf. #L), so we know what is gone when WeakRef==null

static Map<String, String>               filteredRealmLabel = new ConcurrentHashMap<>();
                                        
public static record LggrStringPair(Lggr lgr, String str) {} // Java 14 record instead of class brimborium
protected static Queue<LggrStringPair>   logBuffer = new ConcurrentLinkedQueue<>();
protected static boolean                 logBuffered = false;

protected static Queue<Lggr>             nrBuffer = new ConcurrentLinkedQueue<>();
protected static boolean                 nrBuffered = false;

public static final Pattern              blankPttrn = Pattern.compile("\\s+");
public static final Pattern              illglLblChrsPttrn = Pattern.compile("[^#@A-Za-z0-9_]");
public static final Pattern              illglRlmChrsPttrn = Pattern.compile("\\W");

public static ExecutorService            exctrService = Executors.newFixedThreadPool(10);

//https://www.baeldung.com/java-concurrent-map
//Hashtable: 1142.45  SynchronizedHashMap: 1273.89  ConcurrentHashMap: 230.2

// Singleton. No constructor necessary.
// TODO #1528b1ea Singleton as single-element enum:
//   As of release 1.5, there is a third approach to implementing singletons. Simply make an enum type with one element:
//   [...]
//   This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free ,
//   and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks.

private LogSocket() {}

public static void onOpen() throws IOException {
	//WebSocketImpl1:
	// websocket.sendText("!GREETS LogSocketWs="+LogSocket.shortClObjID(LogSocket.sezs));
	// makes bug. WebSocketImpl2 hangs. ?? due to synchronized?? Initial greeting done in connect(). Works differently in Javascript.
}

public static void onClose(Session sess, Integer statuscode, String reason) {
	// #3ebe778e TODO reconnect after timeout, buffer
	System.err.println("---- LogSocket: onClose LogSocket /"+Nr+" Session="+shortClObjID(sess)+" statuscode="+statuscode+" reason="+reason);	
	shutDown = true;
}

public static void onError(Session sess, Throwable thrbl) {
	System.err.println("---- LogSocket: onError LogSocket /"+Nr+" Session="+shortClObjID(sess)+" Throwable.getMessage()="+thrbl.getMessage());	
}

static public void onMessage(String msg, Session sess) {
	String[] cmd = blankPttrn.split(msg, 2); 

	switch (cmd[0]) {
	case "/START":
		Integer n;
		try { n = Integer.parseInt(cmd[1]);
		} catch (Exception e) {
			complain("LogSocketWs_ERROR_12: /START: "+e.getClass().getName()+" "+e.getMessage());
			//TODO close websocket
			return;
		}
		if (Nr!=null && !Nr.equals(n)) complain("LogSocketWs_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
		Nr = n;
		if (nrBuffered ) { releaseNrBuffer(); }
		if (logBuffered ) {	releaseLogBuffer(); }
		return;

	case "/PING":
		try {
			websocket.sendText("/PING "+"LogSocket /"+Nr+" is alive! "+numLggrs+" loggers created." ); // TODO #495e57b8
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_13 (TODO) "+e.getMessage());
			shutDown = true;
		}
		return;

	case "/GC":
		System.gc();
		return;

	case "/FILTER1_ADD":
		for( String ruleStr : blankPttrn.split(cmd[1]) ) {
			try {
				Filter.applyRule( Filter.parseRuleString(ruleStr) );
				
			} catch(FilterError e) {// Rule already exists
				complain("LogSocket_ERROR_17: "+e.getMessage());
			} catch(FilterRuleError e) {// Syntax error
				complain("LogSocket_ERROR_18: Filter rule syntax error "+e.getMessage());
			}

		}
		return;
	}
	
	complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
}



private static void connect() { // TODO https://resilience4j.readme.io/docs/getting-started Retries with Exponential Backoff and Jitter
	if (websocket!=null) {
		System.err.println("---- LogSocket_ERROR_6: Bug/FIXME: WebSocket already there.");
		return;
	}	
	websocket = new WebSocketImpl1(); // !!!!!!!!!!!!!!!!!!!!!!!!!! #6b31fbdc
	shutDown = !websocket.connect(uri);
	
	if (!shutDown) {
		try {
			websocket.sendText("!GREETS");
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_8 (TODO) "+e.getMessage());
			shutDown = true;
		}
	}
}
	

public static Lggr newLggr(Object o, String realm, String label) {
	return newLggr(realm, label+"#"+shortClObjID(o) , o.toString());  //TODO JS
}
public static Lggr newLggr(String realm, String label) {
	return newLggr(realm, label, "");
}

public static synchronized Lggr newLggr(String realm, String label, String comment) { // label e.g. #bla1#BLA77, which is two labels that can be filtered separately.
// Synchronized static methods are synchronized on the class object

	if ( websocket==null ) connect();

	//DEV update JS   // DOCU
	String checkedLabel = label;
	if (label.isEmpty()) {
		checkedLabel = "#NOLABEL";
	} else if (label.charAt(0)!='#') {
		checkedLabel = "#"+label; // else bug!
	}
		
	String checkedRealm = illglRlmChrsPttrn.matcher(realm).replaceAll("");
	if (checkedRealm.isEmpty()) checkedRealm="Errr";
	String checkedRealmLabel = checkedRealm + (checkedLabel=illglLblChrsPttrn.matcher(checkedLabel).replaceAll(""));

	String filtered;
	if ( "E".equals( filtered=filteredRealmLabel.get(checkedRealmLabel) ) ) { //DOCU filter1 //DEV #6cb5e491
		System.out.println("newLggr FILTERED on creation: "+checkedRealm+" "+checkedLabel+" "+comment+( checkedRealmLabel.equals(realm+label) ? "" : " [REAL/LABEL CORRECTED]" ));  //DIAGN
		return new Lggr(checkedRealm, checkedLabel, 0, "", 0);
	}
	// ----------------------
	
	// Duplicate?
	Integer lastLggrN2 = realmLabel2lastLggrN2.get(checkedRealmLabel);
	int n2 = lastLggrN2==null ? 0 : lastLggrN2+1;
	realmLabel2lastLggrN2.put(checkedRealmLabel, n2);


	long labelsCode = Filter.registerLabels( Arrays.stream(checkedLabel.split("#")) );

	ArrayList<Tuple<String,WeakReference<Lggr>>> lggrList = null;
	
	Map<Long, ArrayList<Tuple<String,WeakReference<Lggr>>>> labelsCode2LggrList = realm2labelsCode2LggrList.get(checkedRealm);
	if (null==labelsCode2LggrList) {
		labelsCode2LggrList =  new ConcurrentHashMap<>();
		lggrList = new ArrayList<>();
	} else {
		lggrList = labelsCode2LggrList.get(labelsCode);
		if (null==lggrList) {
			lggrList = new ArrayList<>();
		} else {
			// Remove no longer referenced loggers from list:
			lggrList.removeIf( tpl -> {
				if (tpl.t2.get()==null) {
					String longId2 = tpl.t1+"/"+Nr;
					// #L Different longId syntax: Nr might have been unknown at moment of creation of list entry
					complain("TODO #74bf4bb lggr "+longId2+" is gone.");
					//...
					return true;
				}
				return false;
			});
		}
	}

	Lggr newLggr = new Lggr(
			checkedRealm, checkedLabel,
			n2, // Realm+Label duplicate number
			( comment = comment.trim()+( checkedRealmLabel.equals(realm+label) ? "" : " [REAL/LABEL CORRECTED]" ) ),
			++numLggrs
			);
	newLggr.on = !"M".equals(filtered); //DOCU filter1 //DEV #6cb5e491

	// #L
	lggrList.add(new Tuple<String, WeakReference<Lggr>>(checkedRealmLabel+(n2==0?"":";"+n2), new WeakReference<Lggr>(newLggr))); 


	if (Nr==null) { // E.g. websocket not yet ready
		nrBuffer.add(newLggr);
		nrBuffered = true;
	} else {  // Since Nr exists, websocket works (except glitch)
		makeKnown(newLggr);
	}


	System.out.println("newLggr on="+newLggr.on+" ignore="+newLggr.ignore+" "+realm+" "+label+" "+comment); //DIAGN

	return newLggr;
}


protected static void makeLggrIdStrings(Lggr lgr) {
	if ( lgr.shortId!=null) { return; }
	if ( lgr.n2!=0 ) { lgr.longId = lgr.realm + "/" + Nr + lgr.label + ";" + lgr.n2;
	} else           { lgr.longId = lgr.realm + "/" + Nr + lgr.label; }
	
	if (Nr!=null) lgr.shortId = "/"+Nr+"_"+lgr.nr;
}
	

private static boolean makeKnown(Lggr lgr) { // FIXME #12fe3d9c %NEW_LGGR null Jsp/null#HELLOWORLD (UTF-8 test: ðŸ‘â†‘) Throwaway logger in declaration
	try {
		websocket.sendText("!NEW_LGGR "
				+ (lgr.on?"1 ":"0 ")
				+ lgr.shortId + " "
				+ lgr.longId
				+ (lgr.comment!=null ? " "+lgr.comment : "")); // see also GC_LGGR
		// In JavaScript lgr gets registered in a FinalizationRegistry
		lgr.ignore = false;

	} catch (Exception e) {
		System.err.println("---- LogSocket_ERROR_5 Exception: "+e.getMessage());
		lgr.comment = "LogSocket_ERROR_5 Exception: "+e.getMessage();
		lgr.on = false;
		//lgr.ignore = true;
		shutDown = true;
		return false;
	}
	return true;
}

static void releaseNrBuffer() {
	if (Nr==null) { System.err.println("!!!- LogSocket_ERROR_15: FATAL BUG. Nr should not be null"); }
	if (!nrBuffered) return;
	nrBuffered = false;
	while (!nrBuffer.isEmpty()) {
		Lggr bffrdLggr = nrBuffer.remove();
		bffrdLggr.comment += (bffrdLggr.comment.isEmpty() ? "[NR_BUF]" : " [NR_BUF]");
		makeLggrIdStrings(bffrdLggr);
		makeKnown(bffrdLggr);
	}
}



public static boolean notBuffered(Lggr lgr, String msg) {
	if (Nr == null) {
		//debugMsg(0,"!--- LogSocket.log(): BUFFERING to logBuffer while waiting for LogSocket.Nr");
		logBuffer.add( new LggrStringPair(lgr,msg)); // TODO flag
		logBuffered = true;
		return false;
	}
	if (logBuffered) {
		//debugMsg(0,"!--- LogSocket.log(): Calling releaseLogBuffer(). Buffer size="+logBuffer.size());
		// The Nr==null problem concerned every Lggr of this LogSocket, so
		// the ordering remains correct for all messages of this LogSocket ONLY.
		releaseLogBuffer();
		//debugMsg(0,"!--- LogSocket.log(): logBuffer emptied.");
	}
	return true;
}

static void releaseLogBuffer() {
	logBuffered = false;
	while (!logBuffer.isEmpty()) {
		LggrStringPair pair = logBuffer.remove();
		Lggr bffrdLggr = pair.lgr;
		makeLggrIdStrings(bffrdLggr);
		log(bffrdLggr, pair.str, '~', 2); // #c29e692
	}
}


protected static void complain(String txt) { //TODO JavaScript
	System.err.println("!!-- "+txt);
	try {
		websocket.sendText("/ERROR /"+Nr+" "+txt);
	} catch (IOException e) {
		// Maybe that was the reason for the complaint
	}
}

// Logging services: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

public static boolean log(Lggr lgr, String msg) { return log(lgr, msg, '*', 0); }
public static boolean logM(Lggr lgr, String msg) { return log(lgr, msg, '+', 0); } //TODO Javascript
public static boolean logErr(Lggr lgr, String msg) { return log(lgr, msg, '+', 1); } //TODO Javascript
//hardwired #c29e692  logBuf(Lggr lgr, String msg) { return log(lgr, msg, '~', 2); } //DONE Javascript
public static boolean logCmd(Lggr lgr, String cmd) { return log(lgr, cmd, '$', 0); } //TODO Javascript

private static final String[] flag2Str = {" ", "&E ", "&B "}; //for performance: flag as it appears in sendText(...) incl. surroundings 
// #2fa32174   0 == nothing, 1 == Error  2 == Buffered //TODO 3 == Timer

//TODO Refactor copy-paste
public static boolean log(Lggr lgr, String msg, char firstChar, int flag) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		//isOpen = false; //TODO JS: needed?
		return false;
	}

	if ( notBuffered(lgr, msg) ) {
		try {
			websocket.sendText( firstChar+lgr.longId+"&"+lgr.shortId+"&"+(++lgr.numMsgs)+flag2Str[flag]+msg );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_4 (TODO) "+e.getMessage());
			shutDown = true;
			return false;
		}
	} // else: notBuffered(lgr, msg) does logBuffer.add( new LggrStringPair(lgr,msg));
	return true;
}

// Global timers managed by LogSocketServer
public static boolean timerStartStop(Lggr lgr, String timerName, boolean start) {
	if (timerName.contains(" ")) {
		logErr(lgr, "Bad timer name \""+timerName+"\". Doing nothing.");
		return false;
	}
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		//isOpen = false; //TODO JS: needed?
		return false;
	}

	String msg = (start ? "!T_START " : "!T_STOP ") + timerName;
	if ( notBuffered(lgr, msg) ) {
		try {
			websocket.sendText( msg );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_7 (TODO) "+e.getMessage());
			shutDown = true;
		}
	}
	return true;
}

//Internal command
public static boolean sendCmd(Lggr lgr, String cmd) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		//isOpen = false; //TODO JS: needed?
		return false;
	}
	if ( notBuffered(lgr, cmd) ) {
		try {
			websocket.sendText( cmd );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_3 (TODO) "+e.getMessage());
			shutDown = true;
		}
	}
	return true;
}

//Send msg disregarding exception
public static boolean sendMsg(String msg) {
	try {
		websocket.sendText( msg );
		return true;
	}
	catch(Exception ignore) {
	return false;
	}
}



// Logging utilities >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public static String getCaller(int skp)	{
	// getCaller(0)=="getCaller"
	// getCaller(1)==called
	return StackWalker.getInstance().
		walk(stream -> stream.skip(skp).findFirst().get()).
		getMethodName();
}

public static String shortClObjID(Object o) {
	return (o==null)?"null":Stream.of(o.toString().split("[.]")).reduce((first,last)->last).get();
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public static class TEST { // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

public static void main(String[] args) {
	System.out.println("LogSocket.TEST...");

}
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
}


// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/* Error collection
 * 
complain("LogSocket_ERROR_17: Filter rule already exists");
complain("LogSocket_ERROR_16: Wrong LogSocket.Nr message=\""+msg+"\"");
System.err.println("!!!- LogSocket_ERROR_15: FATAL BUG. Nr should not be null"); }
complain("LogSocketWs_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
System.err.println("!!!- LogSocket_ERROR_13 (TODO) "+e.getMessage());
complain("LogSocketWs_ERROR_12: /START: "+e.getClass().getName()+" "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_11 "+e.getMessage());
complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
complain("LogSocket_ERROR_9: Logger to be stopped never existed. realm=\""+realm+"\" labelDW=\""+labelDW+"\"");
System.err.println("!!!- LogSocket_ERROR_8 (TODO) "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_7 (TODO) "+e.getMessage());
System.err.println("---- LogSocket_ERROR_6: Bug/FIXME: WebSocket already there.");
System.err.println("---- LogSocket_ERROR_5 Exception: "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_4 (TODO) "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_3 (TODO) "+e.getMessage());


*/