package florifulgurator.logsocket.javalggr;

import static florifulgurator.logsocket.utils.MGutils.*;
import florifulgurator.logsocket.javalggr.Filter.FilterError;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import javax.websocket.Session;


import java.io.IOException;
import java.lang.ref.Cleaner;
import java.lang.ref.WeakReference;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;



@WebListener                             // javax.servlet.annotation for ServletContextListener to shut down ExecutorService
public class LogSocket implements ServletContextListener  {

static IWebSocket                        websocket = null; // WebSocketImpl1 javax.websocket // #6b31fbdc
                                                           // WebSocketImpl2 java.net.http.WebSocket TODO
                                                           
protected static Integer                 Nr = null;  // Unique ID generated by LogSocketServer & set via "/START Nr"
private static URI                       wsUri = URI.create("ws://localhost:8080/logsocket/ws");  // DOCU #57977fd8 LogSocketServer URI HARDWIRED
protected static boolean                 shutDown = false;
protected static boolean                 isOpen = false; // == true after /START was OK

private static Integer                   numLggrs = 0;	//Count of created Loggers. Not seriously used.

private static Map<String,Integer>       realmLabel2lastLggrN2 = new ConcurrentHashMap<>();
// DOCU #681a8b4e 
// Duplicates are counted according to the labels string passed upon logger creation.
// Sub-label ordering is relevant here, but not for filtering:
// The filter mechanism uses a long integer labelsCode bit map, where sub-label ordering is irrelevant.

//--- https://www.baeldung.com/java-concurrent-map Hashtable: 1142.45  SynchronizedHashMap: 1273.89  ConcurrentHashMap: 230.2

static Map<String, Map<Long, ArrayList<LggrRefRcrd>>>
                                         realm2labelsCode2LggrRefRcrdList = new ConcurrentHashMap<>();
static record LggrRefRcrd(String longIdX, int nr, boolean[] ignr, WeakReference<Lggr> wref) {}  // #longIdX // ignr[0] is modifyable 
// Lggr data needed for cleanup after WeakReference became null

static Map<String, String>               filteredRealmLabel = new ConcurrentHashMap<>();
                                        
public static record LggrMsgTms(Lggr lgr, String str, double T) {}
protected static Queue<LggrMsgTms>       logBuffer = new ConcurrentLinkedQueue<>();
protected static boolean                 logBuffered = false;

protected static Queue<Lggr>             nrBuffer = new ConcurrentLinkedQueue<>();
protected static boolean                 nrBuffered = false;

public static final Pattern              blankPttrn = Pattern.compile("\\s+");
public static final Pattern              lineBrkPttrn = Pattern.compile("[\\r\\n]+");
public static final Pattern              illglLblChrsPttrn = Pattern.compile("[^#@A-Za-z0-9_]"); // DOCU #40bf1ecb Label Syntax
public static final Pattern              illglRlmChrsPttrn = Pattern.compile("\\W");			 // Realm Syntax

private static Map<String, Optional<CompletableFuture<String>>>
                                         shortId2CFuture = new ConcurrentHashMap<>(); 
// For logs with buttons. ConcurrentHashMap does not allow null values.

public static ExecutorService            exctrService = Executors.newFixedThreadPool(4);

protected static final Cleaner           cleaner = Cleaner.create();
protected static final LinkedBlockingQueue<ArrayList<LggrRefRcrd>>
                                         cleanupQ = new LinkedBlockingQueue<>();


public void contextInitialized(ServletContextEvent sce) {
	System.out.println(">>>>>>>>>> LogSocket is starting <<<<<<<<<<");
} 
public void contextDestroyed(ServletContextEvent sce) { 
	exctrService.shutdownNow(); // Tomcat can't shut down ExecutorService
	System.gc();
	System.out.println(">>>>>>>>>> LogSocket /"+Nr+" is about to be shut down <<<<<<<<<<");
}




public static void onOpen() {
	LogSocket.exctrService.execute( ()-> {
		try {
			websocket.sendText("!GREETS");
		} catch (IOException e) {
			System.err.println("!!!! LogSocket: onOpen failed catastrophically: "+e.getClass().getName()+" "+e.getMessage());
			shutDown = true; isOpen = false;
			websocket.close();
			websocket=null;
		}
	} );

	//WebSocketImpl1:
	// websocket.sendText("!GREETS LogSocketWs="+LogSocket.shortClObjID(LogSocket.sezs));
	// makes bug. WebSocketImpl2 hangs. ?? due to synchronized?? Initial greeting done in connect(). Works differently in Javascript.
}

public static void onClose(Session sess, Integer statuscode, String reason) {
	// #3ebe778e TODO reconnect after timeout, buffer
	shutDown = true; isOpen = false;
	System.gc();
	System.out.println("==== LogSocket: onClose LogSocket /"+Nr+" Session="+shortClObjID(sess)+" statuscode="+statuscode+" reason="+reason);	
}

public static void onError(Session sess, Throwable thrbl) {
	System.err.println("---- LogSocket: onError LogSocket /"+Nr+" Session="+shortClObjID(sess)+" Throwable.getMessage()="+thrbl.getMessage());	
}

static public void onMessage(String msg, Session sess) {
	String[] cmd = blankPttrn.split(msg, 2); 

	switch (cmd[0]) {
	case "/START":
		Integer n;
		try { n = Integer.parseInt(cmd[1]);
		} catch (Exception e) {
			complain("LogSocketWs_ERROR_12: /START: "+e.getClass().getName()+" "+e.getMessage());
			//TODO close websocket
			return;
		}
		if (Nr!=null && !Nr.equals(n)) complain("LogSocketWs_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
		Nr = n;
		isOpen = true;
		if (nrBuffered ) { releaseNrBuffer(); }
		if (logBuffered ) {	releaseLogBuffer(); }
		return;

	case "/PING":
		try {
			websocket.sendText("%/ LogSocket /"+Nr+" using javax.websocket is alive! "
				+numLggrs+" loggers created in realms "
				+realm2labelsCode2LggrRefRcrdList.keySet().stream().collect(Collectors.joining(", "))
			);
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_13 (TODO) "+e.getMessage());
			shutDown = true; isOpen = false;
		}
		return;

	case "/GC":
		System.gc();
		return;

	case "/FLTR_ADD":
		for( String ruleStr : blankPttrn.split(cmd[1]) ) {
			try {
				Filter.applyRule( Filter.parseRuleString(ruleStr) );
			} catch(FilterError e) {
				complain("LogSocket_ERROR_17: "+e.getMessage());
			}
		}
		return;

	case "/CFT":
		CompletableFuture<String> cft;
		try {
			String[] spl = blankPttrn.split(cmd[1], 2);
			cft = shortId2CFuture.get(spl[0]).get();
			shortId2CFuture.put(spl[0], Optional.empty());
			if ( cft!=null ) {
				if ( cft.isDone() ) LogSocket.sendMsg("%/ALERT_R Button click:<br/>CompletableFuture.isDone() already");
				else cft.complete(spl[1]);
			}
		} catch  (Exception e) {
			complain("LogSocket_ERROR_19: "+e.getClass().getName()+" "+e.getMessage()+" msg="+msg);
			LogSocket.sendMsg("%/ALERT_R Button click:<br/>"+e.getClass().getName());
			return;
		}
		if ( cft==null ) LogSocket.sendMsg("%/ALERT_R Button click:<br/>CompletableFuture is null!");
		return;

	}
	
	complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
}



private static void connect() { 
	if (websocket!=null) {
		System.err.println("---- LogSocket_ERROR_6: Bug/FIXME: WebSocket already there.");
		return;
	}
	websocket = new WebSocketImpl1(); // !!!!!!!!!!!!!!!!!!!!!!!!!! #6b31fbdc
	websocket.connect(wsUri);
}
	

public static Lggr newLggr(Object o, String realm, String label) {
	return newLggr(realm, label+"#"+shortClObjID(o) , o.toString());  //TODO JS
}
public static Lggr newLggr(String realm, String label) {
	return newLggr(realm, label, "");
}

public static synchronized Lggr newLggr(String realm, String label, String comment) { // label e.g. #bla1#BLA77, which is two labels that can be filtered separately.
// Synchronized static methods are synchronized on the class object

	if ( websocket==null ) connect();

	//DEV update JS   // DOCU
	String checkedLabel = label;
	if (label.isEmpty()) {
		checkedLabel = "#NOLABEL"; // DOCU #40bf1ecb
	} else if (label.charAt(0)!='#') {
		checkedLabel = "#"+label; // else bug!
	}
		
	String checkedRealm = illglRlmChrsPttrn.matcher(realm).replaceAll("");
	if (checkedRealm.isEmpty()) checkedRealm="Errr";  // DOCU #40bf1ecb
	String checkedRealmLabel = checkedRealm + (checkedLabel=illglLblChrsPttrn.matcher(checkedLabel).replaceAll(""));

	String filtered;
	if ( "E".equals( filtered=filteredRealmLabel.get(checkedRealmLabel) ) ) { //DOCU filter1 //DEV #6cb5e491
		System.out.println("newLggr FILTERED on creation: "+checkedRealm+" "+checkedLabel+" "+comment+( checkedRealmLabel.equals(realm+label) ? "" : " [REAL/LABEL CORRECTED]" ));  //DIAGN
		return new Lggr(checkedRealm, checkedLabel, 0, 0L, "", 0);
	}
	// ----------------------
	
	long labelsCode = Filter.registerLabels( Arrays.stream(checkedLabel.split("#")).skip(1) );

	ArrayList<LggrRefRcrd> lggrRefRcrdList = null;
	
	Map<Long, ArrayList<LggrRefRcrd>> labelsCode2LggrRefRcrdList = realm2labelsCode2LggrRefRcrdList.get(checkedRealm);
	
	if (null==labelsCode2LggrRefRcrdList) {
		labelsCode2LggrRefRcrdList =  new ConcurrentHashMap<>();
		lggrRefRcrdList = new ArrayList<>();
		realm2labelsCode2LggrRefRcrdList.put(checkedRealm, labelsCode2LggrRefRcrdList);
		labelsCode2LggrRefRcrdList.put(labelsCode, lggrRefRcrdList);
	} else {
		lggrRefRcrdList = labelsCode2LggrRefRcrdList.get(labelsCode);
		if (null==lggrRefRcrdList) {
			lggrRefRcrdList = new ArrayList<>();
			labelsCode2LggrRefRcrdList.put(labelsCode, lggrRefRcrdList);
		}
	}
	
	// Duplicate?
	Integer lastLggrN2 = realmLabel2lastLggrN2.get(checkedRealmLabel);
	int n2 = lastLggrN2==null ? 0 : lastLggrN2+1;
	realmLabel2lastLggrN2.put(checkedRealmLabel, n2);

	Lggr newLggr = new Lggr(
			checkedRealm, checkedLabel,
			n2,
			labelsCode,
			( comment = comment.trim()+( checkedRealmLabel.equals(realm+label) ? "" : " [REAL/LABEL CORRECTED]" ) ),
			++numLggrs
			);
	newLggr.on = !"M".equals(filtered); //DOCU filter1 //DEV #6cb5e491

	LggrRefRcrd lRR = new LggrRefRcrd(checkedRealmLabel+";"+n2, numLggrs, new boolean[]{true}, new WeakReference<>(newLggr));
	newLggr.lggrRefRcrd = lRR;

	synchronized (lggrRefRcrdList) {
		lggrRefRcrdList.add(lRR); // #longIdX
	}

	if (Nr==null) { // E.g. websocket not yet ready
		nrBuffer.add(newLggr);
		nrBuffered = true;
	} else {  // Since Nr exists, websocket works (except glitch)
		makeKnown(newLggr);
	}


	System.out.println("newLggr on="+newLggr.on+" ignore="+newLggr.ignore+" "+Long.toBinaryString(labelsCode)
		+" "+realm+" "+label+" "+comment
	); //DIAGN

	return newLggr;
}


static {
	// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	exctrService.execute( () -> {
		System.out.println("==== WeakRef cleanup daemon running...");
		ArrayList<LggrRefRcrd>      qEl;
		Set<ArrayList<LggrRefRcrd>> qElSet = new HashSet<>(); //TODO more performant implementation of Set
		ArrayList<String>           cmdArgList = new ArrayList<>();
		String DIAGNmsg[] = {""};

		while (!Thread.interrupted()) {
			try {
				qEl = cleanupQ.take(); // wait for first element in queue
				Thread.sleep(333);     // likely there will come more, wait for them
			} catch (InterruptedException e) {
				break;
			}
			DIAGNmsg[0] = "==== WeakRef cleanup: ";
			
			do { qElSet.add(qEl);	} // now take them all
			while ( (qEl=cleanupQ.poll()) != null ); 
			
			qElSet.forEach( (lggrRefRcrdList) -> {
				synchronized (lggrRefRcrdList) { // >>>>>>>>>>>
					// Remove no longer referenced loggers from list:
					lggrRefRcrdList.removeIf( rcrd -> {
						if (rcrd.wref.get()==null) {
							String shortId = "/"+Nr+"_"+rcrd.nr;
							DIAGNmsg[0] += " "+shortId;
							shortId2CFuture.remove(shortId);
							if (!rcrd.ignr[0]) {
								// #5f5d8a51
								// !GC_LGGR args for later use. We hold the lock on lggrRefRcrdList as shortly as possible
								String[] spl = rcrd.longIdX.split("#",2);
								cmdArgList.add(	shortId +" "+ spl[0]+"/"+Nr+"#"+spl[1] );
								// A "longId2" that can have ";0" at the end unlike longId #66f78f43
								DIAGNmsg[0] += "*";
							}
							return true;
						}
						return false;
					});
				} // synchronized <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
			});
			
			if (isOpen && !Thread.interrupted()) {
				cmdArgList.forEach( (str) -> {
					try { websocket.sendText("!GC_LGGR " + str);
					} catch (IOException ignore) {}
				});
			}
			cmdArgList.clear();
			qElSet.clear();
			System.out.println(DIAGNmsg[0]);
			
		} // wait for work again
		System.out.println("==== WeakRef cleanup daemon stopped.");
	}); //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
} // END static


protected static void finalizeLggr(String longId, long labelsCode) {
// Registered after nrBuffer/logBuffer are released and their Lggr references cleared.
// I.e. at this point LogSocket.Nr is known, while in realm2labelsCode2LggrRefRcrdList it is not known.
	ArrayList<LggrRefRcrd> lggrRefRcrdList = null;
	try { lggrRefRcrdList = realm2labelsCode2LggrRefRcrdList.get(longId.split("/",2)[0]).get(labelsCode); }
	catch (Exception e) { //NullPointerException
		System.err.println("---- LogSocket_ERROR_18 lggrRefRcrdList not found in realm2labelsCode2LggrRefRcrdList: "+e.getMessage());
	}
	if (lggrRefRcrdList != null) cleanupQ.add(lggrRefRcrdList);
}


protected static void makeLggrIdStrings(Lggr lgr) {
	if ( lgr.shortId!=null) { return; }
	if ( lgr.n2!=0 ) { lgr.longId = lgr.realm + "/" + Nr + lgr.label + ";" + lgr.n2;
	} else           { lgr.longId = lgr.realm + "/" + Nr + lgr.label; }
	
	if (Nr!=null) lgr.shortId = "/"+Nr+"_"+lgr.nr;
	
	// DOCU #longId #shortId
	// Filter and Cleaner use a #longIdX without LogSocket.Nr (not necessarily known at creation of Filter/Cleaner entry).
}
	

private static boolean makeKnown(Lggr lgr) { // FIXME #12fe3d9c %NEW_LGGR null Jsp/null#HELLOWORLD (UTF-8 test: ðŸ‘â†‘) Throwaway logger in declaration
	try {
		lgr.ignore = false;	lgr.lggrRefRcrd.ignr[0] = false; // #5f5d8a51
		
		String lid = lgr.longId; // to be sure no reference to lgr is passed to lgr.cleanable
		long lbc = lgr.labelsCode;
		lgr.cleanable = cleaner.register(lgr, () -> finalizeLggr(lid, lbc) );
		
		websocket.sendText("!NEW_LGGR "
				+ (lgr.on?"1 ":"0 ")
				+ lgr.shortId + " "
				+ lgr.longId
				+ (lgr.comment!=null ? " "+lgr.comment : "")); // see also GC_LGGR

	} catch (Exception e) {
		System.err.println("---- LogSocket_ERROR_5 Exception: "+e.getMessage());
		lgr.comment = "LogSocket_ERROR_5 Exception: "+e.getMessage();
		lgr.on = false;
		lgr.cleanable = null;
		shutDown = true; isOpen = false;
		return false;
	}
	return true;
}

static void releaseNrBuffer() {
	if (Nr==null) { System.err.println("!!!- LogSocket_ERROR_15: FATAL BUG. Nr should not be null"); }
	if (!nrBuffered) return;
	nrBuffered = false;
	while (!nrBuffer.isEmpty()) {
		Lggr bffrdLggr = nrBuffer.remove();
		bffrdLggr.comment += (bffrdLggr.comment.isEmpty() ? "[NR_BUF]" : " [NR_BUF]");
		makeLggrIdStrings(bffrdLggr);
		makeKnown(bffrdLggr);
	}
}



public static boolean notBuffered(Lggr lgr, String msg) {
	if (Nr == null) {
		//debugMsg(0,"!--- LogSocket.log(): BUFFERING to logBuffer while waiting for LogSocket.Nr");
		logBuffer.add( new LggrMsgTms(lgr, msg, round1(sysT_ms()) ) ); // TODO flag
		logBuffered = true;
		return false;
	}
	if (logBuffered) {
		//debugMsg(0,"!--- LogSocket.log(): Calling releaseLogBuffer(). Buffer size="+logBuffer.size());
		// The Nr==null problem concerned every Lggr of this LogSocket, so
		// the ordering remains correct for all messages of this LogSocket ONLY.
		releaseLogBuffer();
		//debugMsg(0,"!--- LogSocket.log(): logBuffer emptied.");
	}
	return true;
}

static void releaseLogBuffer() {
	logBuffered = false;
	while (!logBuffer.isEmpty()) {
		LggrMsgTms pair = logBuffer.remove();
		Lggr bffrdLggr = pair.lgr;
		makeLggrIdStrings(bffrdLggr);
		log(bffrdLggr, pair.str, '-', 2); // #c29e692
	}
}


protected static void complain(String txt) { //TODO JavaScript
	System.err.println("!!-- "+txt);
	try {
		websocket.sendText("%/ERROR /"+Nr+" "+txt);
	} catch (IOException e) { // Maybe that was the reason for the complaint
		shutDown = true; isOpen = false;
	}
}

// Logging services: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

public static boolean log(Lggr lgr, String msg) { return log(lgr, msg, '*', 0); }
public static boolean logM(Lggr lgr, String msg) { return log(lgr, msg, '+', 0); } //TODO Javascript
public static boolean logErr(Lggr lgr, String msg) { return log(lgr, msg, '+', 1); } //TODO Javascript
public static boolean logCmd(Lggr lgr, String cmd) { return log(lgr, cmd, '$', 0); } //TODO Javascript

private static final String[] flag2Str = {" ", "&E ", "&B ", "&P "}; //for performance: flag as it appears in sendText(...) incl. surroundings 
// #2fa32174   0 == nothing, 1 == Error  2 == Buffered 3 == Promise(JS)/CompletableFuture(Java)

//TODO Refactor copy-paste
public static boolean log(Lggr lgr, String msg, char firstChar, int flag) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}

	if ( notBuffered(lgr, msg) ) { // FIXME #536c8c47 flag and firstChar get lost when buffered
		try {
			websocket.sendText( firstChar+lgr.longId+"&"+lgr.shortId+"&"+(++lgr.numMsgs)+flag2Str[flag]+msg );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_4 (TODO) "+e.getMessage());
			shutDown = true; isOpen = false;
			return false;
		}
	} // else: notBuffered(lgr, msg) does logBuffer.add( new LggrMsgTms(lgr,msg));
	return true;
}


public static CompletableFuture<String> logCFtr(Lggr lgr, String msg) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return CompletableFuture.failedFuture(new Exception("LogSocket is shut down."));
	}
	
	if (Nr != null) { // not buffering
		Optional<CompletableFuture<String>> opt;
		if ( (opt=shortId2CFuture.get(lgr.shortId))!= null && !opt.isEmpty() ) {
			opt.get().completeExceptionally(new Throwable("logCFtr: Old CompletableFuture completed exceptionally in favour of a new one."));
			//DEL return CompletableFuture.failedFuture(new Exception("ERROR: Last Future not yet completed."));
		}
		CompletableFuture<String> cft = new CompletableFuture<String>();
		shortId2CFuture.put(lgr.shortId, Optional.of(cft));
		try {
			websocket.sendText( '+'+lgr.longId+"&"+lgr.shortId+"&"+(++lgr.numMsgs)+flag2Str[3]+lineBrkPttrn.split(msg, 2)[0]+"\n/CFT "+lgr.shortId );
			// Here (not elswhere) we make sure there are no \n in msg
			// /CFT ... is the command used in client response
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_4 (TODO) "+e.getMessage());
			shutDown = true; isOpen = false;
			return CompletableFuture.failedFuture(new Exception("LogSocket shut down due to exception."));
		}
		return cft;
	}
	return CompletableFuture.failedFuture(new Exception("LogSocket is buffering."));
}


// Global timers managed by LogSocketServer
public static boolean timerStartStop(Lggr lgr, String timerName, boolean start) {
	if (timerName.contains(" ")) {
		logErr(lgr, "Bad timer name \""+timerName+"\". Doing nothing.");
		return false;
	}
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}

	String msg = (start ? "!T_START " : "!T_STOP ") + timerName;
	if ( notBuffered(lgr, msg) ) {
		try {
			websocket.sendText( msg );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_7 (TODO) "+e.getMessage());
			shutDown = true; isOpen = false;
		}
	}
	return true;
}

//Internal command
public static boolean sendCmd(Lggr lgr, String cmd) {
	if (shutDown) {
		lgr.on = false; //TODO all other loggers
		return false;
	}
	if ( notBuffered(lgr, cmd) ) {
		try {
			websocket.sendText( cmd );
		} catch (Exception e) {
			System.err.println("!!!- LogSocket_ERROR_3 (TODO) "+e.getMessage());
			shutDown = true; isOpen = false;
		}
	}
	return true;
}

//Send msg disregarding exception and buffers
public static boolean sendMsg(String msg) {
	try {
		websocket.sendText( msg );
		return true;
	}
	catch(Exception ignore) {
		shutDown = true; isOpen = false;
		return false;
	}
}


// Logging utilities >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
public static String getCaller(int skp)	{
	// getCaller(0)=="getCaller"
	// getCaller(1)==called
	return StackWalker.getInstance().
		walk(stream -> stream.skip(skp).findFirst().get()).
		getMethodName();
}

public static String shortClObjID(Object o) {
	return (o==null)?"null":Stream.of(o.toString().split("[.]")).reduce((first,last)->last).get();
}

public static String stackTraceToString(Exception e) {
	return Arrays.stream(e.getStackTrace()).map( x-> x.toString() ).collect(Collectors.joining("\n"));
}
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


} // class LogSocket <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/* Error collection
 * 
complain("LogSocket_ERROR_19: "+e.getMessage()+" cmd="+cmd);
System.err.println("---- LogSocket_ERROR_18 lggrList not found in realm2labelsCode2LggrList: "+e.getMessage());
complain("LogSocket_ERROR_17: Filter rule already exists");
complain("LogSocket_ERROR_16: Wrong LogSocket.Nr message=\""+msg+"\"");
System.err.println("!!!- LogSocket_ERROR_15: FATAL BUG. Nr should not be null"); }
complain("LogSocketWs_ERROR_14: "+msg+" but already LogSocket.Nr="+Nr);
System.err.println("!!!- LogSocket_ERROR_13 (TODO) "+e.getMessage());
complain("LogSocketWs_ERROR_12: /START: "+e.getClass().getName()+" "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_11 "+e.getMessage());
complain("LogSocket_ERROR_10: Unknown message=\""+msg+"\"");
complain("LogSocket_ERROR_9: Logger to be stopped never existed. realm=\""+realm+"\" labelDW=\""+labelDW+"\"");
System.err.println("!!!- LogSocket_ERROR_8 (TODO) "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_7 (TODO) "+e.getMessage());
System.err.println("---- LogSocket_ERROR_6: Bug/FIXME: WebSocket already there.");
System.err.println("---- LogSocket_ERROR_5 Exception: "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_4 (TODO) "+e.getMessage());
System.err.println("!!!- LogSocket_ERROR_3 (TODO) "+e.getMessage());


*/